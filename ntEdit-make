#!/usr/bin/make -f
# Pipeline for the ntEdit program
# Written by Talha Murathan Goktas

allreads:=$(wildcard $(reads)*)

#required params
#reads=reads
#draft=draft
#k=k

#optional params
#common params
b=$(draft)_k$k
t=1

#ntHits params
p=$(reads)
cutoff=-1
solid=false

#ntEdit params
z=100
i=4
d=5
x=5.000
y=9.000
cap=$(shell echo $$(( $(k)*2 )))
m=0
v=0
##c = $(shell echo $((shell expr $(k) * 1.5):-= ))

SHELL=bash -e -o pipefail
ifeq ($(shell zsh -e -o pipefail -c 'true' 2>/dev/null; echo $$?), 0)
#Set pipefail to ensure that all commands of a pipe succeed.
SHELL=zsh -e -o pipefail
# Report run time and memory usage with zsh.
export REPORTTIME=1
export TIMEFMT=time user=%U system=%S elapsed=%E cpu=%P memory=%M job=%J
endif

# Record run time and memory usage in a file using GNU time.
ifdef time
ifneq ($(shell command -v gtime),)
gtimeNtedit=command gtime -v -o ntedit_k$k.time
gtimeNthits=command gtime -v -o nthits_k$k.time
else
gtimeNtedit=command time -v -o ntedit_k$k.time
gtimeNthits=command time -v -o nthits_k$k.time
endif
endif


.PHONY: all version help check ntedit
.DELETE_ON_ERROR:
.PRECIOUS: $(draft)_edited.fa %.tsv %.bf

all: help 
# Help
help:
	@echo ""
	@echo "Usage: ./ntedit-make ntedit [OPTION=VALUE]..."
	@echo ""
	@echo "Options:"
	@echo "	draft	Draft genome assembly (FASTA, Multi-FASTA, and/or gzipped compatible), REQUIRED"
	@echo "	reads	read name [reads]. Accepatble file formats: fastq, fasta, gz, bz, zip, REQUIRED"
	@echo "	time	logs time and memory usage to file for main steps (Set to 1 to enable logging)"
	@echo "	k	kmer size, REQUIRED"
	@echo "	t	number of threads [default=1]"
	@echo "	b	output file prefix, OPTIONAL"
	@echo ""
	@echo "Options specific to ntHits:"
	@echo "	p	the prefix for output file name (bloom filter)"
	@echo "	solid	output the solid k-mers (non-errornous k-mers)"
	@echo "	cutoff	the maximum coverage of kmer in output in bloom filter"
	@echo ""
	@echo "Options specific to ntEdit:"
	@echo "	z	minimum contig length [default=100]"
	@echo "	i	maximum number of insertion bases to try, range 0-5, [default=4]"
	@echo "	d	maximum number of deletions bases to try, range 0-5, [default=5]"
	@echo "	x	k/x ratio for the number of kmers that should be missing, [default=5.000]"
	@echo "	y	k/y ratio for the number of editted kmers that should be present, [default=9.000]"
	@echo "	cap	cap for the number of base insertions that can be made at one position, [default=k*1.5]"
	@echo "	m	mode of editing, range 0-2, [default=0]"
	@echo "			0: best substitution, or first good indel"
	@echo "			1: best substitution, or best indel"
	@echo "			2: best edit overall (suggestion that you reduce i and d for performance)"
	@echo "	v	verbose mode (-v 1 = yes, default = 0, no)"
	@echo ""
	@echo "Example:	Files in directory are myDraft.fa myReads1.fq myReads2.fq"
	@echo "		./ntedit-make ntedit draft=myDraft reads=myReads k=64 c=2 or"
	@echo "		./ntedit-make ntedit draft=myDraft reads=myReads k=64 solid=true"
	@echo "To ensure that the pipeline runs correctly, make sure that the following tools are in your PATH: ntedit, nthits"
	@echo "We suggest you to set the cutoff parameter yourself or set solid=true to set it automatically."

# Version
version:
	@echo "ntedit-make version no"

clean:
	rm -f *.amb *.ann *.bwt *.pac *.sa *.dist.gv *.fai *.bed *.molecule.tsv *.sortbx.bam

#Run ntEdit
ntedit: check $(draft)_k$k_edited.fa

check:
ifndef draft
	$(error draft is not defined)
endif
ifndef reads
	$(error reads is not defined)
else
	$(info read files that are found: $(allreads))	
endif
ifndef k
	$(error kmer size is not defined)
endif

# Create a .fa file that is soft linked to .fasta 
%.fa: %.fasta
	ln -s $^ $@

# Create a .fq.gz file that is soft linked to .fastq.gz 
##%.fq: %.fastq
##	ln -s $^ $@

$(reads)_k$k.bf: $(allreads)
ifeq ($(solid),true)
	$(gtimeNthits) nthits --solid --outbloom -p$p -k$k -t$t $^
else
	$(gtimeNthits) nthits -c$(cutoff) --outbloom -p$p -k$k -t$t $^
endif

$(draft)_k$k_edited.fa: $p_k$k.bf $(draft).fa
	$(gtimeNtedit) ntedit -r $< -f $(word 2,$^) -k $k -b $b -t $t -z $z -i $i -d $d -x $x -y $y -c $(cap) -m $m -v $v
